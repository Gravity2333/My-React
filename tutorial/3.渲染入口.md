# 渲染入口
react的渲染入口是从createRoot开始的，其定义在 [lib/react-dom/index.ts](../lib/react-dom/index.ts)

其中 createRoot函数就是用来创建一个根节点的 即 FiberRootNode节点，并且创建第一个HostRootFiber节点，并且用其初始化 current
```typescript
export function createRoot(container: Container) {
  // 创建FiberRootNode
  const root = createContainer(container);
  return {
    render(element: ReactElement) {
      // TODO
      // 初始化合成事件
      initEvent(container);
      // 更新contianer
      return updateContainer(element, root);
    },
  };
}
```
其中 createContainer就是创建FiberRootNode节点，实现如下:
``` typescript
/** 创建应用根节点FiberRootNode 以及第一个HostRoot节点 hostRootFiber */
const createContainer = (container: Container) => {
  // 第一个hostRoot节点
  const hostRootFiber = new FiberNode(HostRoot, {}, null);
  // 创建整个应用的根节点： FiberRootNode
  const root = new FiberRootNode(container, hostRootFiber);
  // 创建一个hostRootFiber的更新队列 （updateQueue） 存放的是新的root element
  hostRootFiber.updateQueue = new UpdateQueue<ReactElement>();
  return root;
};
```
逻辑也很简单 就是分别调用 FiberRootNode 和 HostRootFiber的构造函数 并且创建对象。

对container完成绑定

在FiberRootNode 的构造函数中，我们完成了对HostRoot与FiberRootNode.current的绑定

最后 还需要给HostRoot节点创建updateQueue 来初始化更新队列

此时我们就获得了  { render(){} } 对象，我们调用render函数即可开启渲染
render函数内部是
1. 初始化合成事件
2. 调用了updateContainer函数 其实现也很简单

```typescript
/**
 * 更新container 需要传入
 * @param element 新的element节点
 * @param root APP根节点
 */
const updateContainer = (element: ReactElement, root: FiberRootNode) => {
  // 默认情况下 同步渲染
  scheduler.runWithPriority(PriorityLevel.IMMEDIATE_PRIORITY, () => {
    // 请求获得当前更新lane
    const lane = requestUpdateLane();
    // 获hostRootFiber
    const hostRootFiber = root.current;
    // 更新的Element元素入队
    hostRootFiber.updateQueue?.enqueue(
      new Update<ReactElement>(element, lane),
      hostRootFiber,
      lane
    );
    // scheduleUpdateOnFiber 调度更新
    scheduleUpdateOnFiber(root.current, lane);
  });
};
```

其中就是，根据root找到当前对应的HostRootFiber节点 把element对象推入其的更新队列

获取当前的scheduler优先级 （默认为 同步优先级）

调用scheduleUpdateOnFiber 开启调度流程！