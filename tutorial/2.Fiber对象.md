# ReactELement -> Fiber
上面说完了ReactElement元素的构建，那么有了元素之后，我们就要到建立虚拟DOM的步骤

# Fiber对象
React中，虚拟Dom是以Fiber的结构存在的，其好处就是增量更新，并且在并发模式下其渲染可打断，重新执行。

Fiber是一个对象，其定义在 [lib/react-reconciler/fiber.ts](../lib/react-reconciler/fiber.ts)

```typescript
/** Fiber节点类 */
export class FiberNode {
  // 唯一id
  key: Key;
  // fiber节点的类型
  tag: WorkTag;
  /** element对应的Type */
  type: ReactElementType;
  /** ref */
  ref: Ref;

  // 对应的dom节点 可能为null
  stateNode: any;
  // 记录状态信息
  memorizedState: any;
  // 记录的Props
  memorizedProps: ReactElementProps;

  // 表示fiber node之间的关系
  index: number; // diff比较的index
  sibling: FiberNode | null; // 兄弟节点
  return: FiberNode | null; //父节点
  child: FiberNode | null; // 子节点

  // flags 副作用
  flags: Flags; // 当前节点的flag
  subTreeFlags: Flags; // 当前节点为根的子树flag的merge
  pendingProps: ReactElementProps; // 待处理的props
  delections: FiberNode[];

  // 更新队列
  updateQueue: UpdateQueue<any> | null;

  // 双缓存
  alternate: FiberNode | null;

  /** lane相关 */
  /** 当前fiber上的更新lanes */
  lanes: Lanes;
  /** 当前fiber的子fiber树上的优先级 */
  childLanes: Lanes;

  constructor(tag: WorkTag, pendingProps: ReactElementProps, key: Key) {
    // 没传key的情况下 都是null 在Diff reconcileArray的时候 会使用index
    this.key = key || null;
    this.tag = tag;
    this.type = null;
    this.ref = null;

    this.stateNode = null;
    this.memorizedState = null;
    this.memorizedProps = null;

    this.index = 0;
    this.sibling = null;
    this.child = null;
    this.return = null;

    // 副作用
    this.flags = NoFlags;
    this.subTreeFlags = NoFlags;
    this.pendingProps = pendingProps;
    this.delections = null;

    this.updateQueue = null;
    this.alternate = null;

    /** lanes相关 */
    this.lanes = NoLanes;
    this.childLanes = NoLanes;
  }
}
```

其内部主要包含一些记录信息
- key 就是ReactElement的key
- type ReactElement的type
- tag: WorkTag 表示Fiber的类型，包含 HostRoot HostComponse HostText FunctionComponent ClassComponent MemoConponent ContextComponent等等
- ref: Ref值

- sibling 兄弟Fiber节点指针
- return 父节点指针
- child 指向第一个字节点
- stateNode 指向对应的真实DOM节点

- alternate 双缓冲树
- updateQueue 当前节点对应的更新队列

- flags fiber操作对应的Flag 比如新增 删除 修改 等等
- subtreeFlags 子树的flag合集
- pendingProps 当前fiber树未构建完成状态下的props
- memorizedProps fiber树构建完成时保存的props 也可能是上一次更新的props
- memoizedState 保存的更新记录信息
- lanes 当前节点对应更新的优先级
- childLanes 当前节点字节点对应的优先级集合
- deletion 本次更细待删除的节点

fiber之间对应的结构如下:

```typescript
<>
    <div></div>
    <ul>
        <li>item1</li>
        <li>item2</li>
        <li>item3</li>
    </ul>
</>
```
![2-1 fiber结构](./images/2-1%20fiber结构.png)

# 容易混淆的两个跟节点
Fiber会构成一棵树，其根Fiber对象为 HostRootFiber ,其本质也是个Fiber对象，其workTag为HostRoot
在HostRootFiber对象上层，对应一个跟节点 FiberRootNode 其类型不是Fiber，其是整个应用的根，保存着全局信息，定义入下
```typescript
/** 只有一个 整个应用的根 */
export class FiberRootNode {
  current: FiberNode;
  container: Container;
  finishedWork: FiberNode | null;

  /** 表示commit阶段收集到的 等待被处理的被动Effect  被动Effect: 不会引起重新渲染的effect*/
  pendingPassiveEffects: PendingPassiveEffect;

  /** 和lane相关的属性 */
  /** 当前还未运行的任务的lane合集 */
  pendingLanes: Lanes;
  /** 已经完成运行的更新对应的lane 在render阶段结束之后设置，在commit阶段置空 类似于finishedWork */
  finishedLane: Lane;

  /** 需要传入container 和 第一个HostRootFiber */
  constructor(conatiner: Container, hostRootFiber: FiberNode) {
    /** 保存container */
    this.container = conatiner;
    this.finishedWork = null;
    /** 需要建立关系：
     *  FiberRootNode.current -> hostRootFiber
     *  hostRootFiber.stateNode -> FiberRootNode
     */
    this.current = hostRootFiber;
    hostRootFiber.stateNode = this;

    /** 初始化pendingPassiveEffect */
    this.pendingPassiveEffects = {
      unmount: [],
      update: [],
    };

    /** 初始化lane */
    this.pendingLanes = NoLanes;
    this.finishedLane = NoLane;
  }
}
```

其中，包含container属性，指向整个应用挂载的容器，也就是我们在createRoot中传入的根真实DOM节点

current指向已经完成渲染的Fiber树的根HostRootFiber节点，由于React采用双缓冲树的方式，所以会有两棵树在FiberRootNode下，current就是指向当前已经完成渲染的那棵树

每个HostRootFiber节点的stateNode属性，都指向这个FiberRootNode根

finishedWork 在render阶段结束之后，指向已经render完成的Fiber树，但是还没有执行commit 并且在commit阶段置为null

pendingLanes 整棵树未执行的优先级lane

finishedLane 在commit阶段用，表示当前更新对应完成的优先级lane

pendingPassiveEffect 表示本次更细收集的Effect副作用

FiberRootNode 和 HostRootFIber的结构关系如下
![alt text](./images/2-2%20fiber结构对象.png)

